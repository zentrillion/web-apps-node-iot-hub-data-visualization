"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const debugModule = require("debug");
const uuid = require("uuid/v4");
const utils_1 = require("./util/utils");
const debug = debugModule("azure:event-hubs:clientEntity");
/**
 * Describes the base class for entities like EventHub Sender, Receiver and Management client.
 * @class ClientEntity
 */
class ClientEntity {
    /**
     * Creates a new ClientEntity instance.
     * @constructor
     * @param {ConnectionContext} context The connection context.
     * @param {string} [name] Name of the entity.
     */
    constructor(context, options) {
        if (!options)
            options = {};
        this._context = context;
        this.address = options.address || "";
        this.audience = options.audience || "";
        this.name = options.name || uuid();
        this.partitionId = options.partitionId;
    }
    /**
     * Provides the current type of the ClientEntity.
     * @return {string} The entity type.
     */
    get type() {
        let result = "ClientEntity";
        if (this.constructor && this.constructor.name) {
            result = this.constructor.name;
        }
        return result;
    }
    /**
     * Negotiates the cbs claim for the ClientEntity.
     * @protected
     * @param {boolean} [setTokenRenewal] Set the token renewal timer. Default false.
     * @return {Promise<void>} Promise<void>
     */
    _negotiateClaim(setTokenRenewal) {
        return __awaiter(this, void 0, void 0, function* () {
            // Acquire the lock and establish a cbs session if it does not exist on the connection.
            // Although node.js is single threaded, we need a locking mechanism to ensure that a
            // race condition does not happen while creating a shared resource (in this case the
            // cbs session, since we want to have exactly 1 cbs session per connection).
            debug("[%s] Acquiring cbs lock: '%s' for creating the cbs session while creating the %s: " +
                "'%s' with address: '%s'.", this._context.connectionId, this._context.cbsSession.cbsLock, this.type, this.name, this.address);
            yield utils_1.defaultLock.acquire(this._context.cbsSession.cbsLock, () => { return this._context.cbsSession.init(); });
            const tokenObject = yield this._context.tokenProvider.getToken(this.audience);
            debug("[%s] %s: calling negotiateClaim for audience '%s'.", this._context.connectionId, this.type, this.audience);
            // Acquire the lock to negotiate the CBS claim.
            debug("[%s] Acquiring cbs lock: '%s' for cbs auth for %s: '%s' with address '%s'.", this._context.connectionId, this._context.negotiateClaimLock, this.type, this.name, this.address);
            yield utils_1.defaultLock.acquire(this._context.negotiateClaimLock, () => {
                return this._context.cbsSession.negotiateClaim(this.audience, tokenObject);
            });
            debug("[%s] Negotiated claim for %s '%s' with with address: %s", this._context.connectionId, this.type, this.name, this.address);
            if (setTokenRenewal) {
                yield this._ensureTokenRenewal();
            }
        });
    }
    /**
     * Ensures that the token is renewed within the predefined renewal margin.
     * @protected
     * @returns {void}
     */
    _ensureTokenRenewal() {
        return __awaiter(this, void 0, void 0, function* () {
            const tokenValidTimeInSeconds = this._context.tokenProvider.tokenValidTimeInSeconds;
            const tokenRenewalMarginInSeconds = this._context.tokenProvider.tokenRenewalMarginInSeconds;
            const nextRenewalTimeout = (tokenValidTimeInSeconds - tokenRenewalMarginInSeconds) * 1000;
            this._tokenRenewalTimer = setTimeout(() => __awaiter(this, void 0, void 0, function* () {
                try {
                    yield this._negotiateClaim(true);
                }
                catch (err) {
                    // TODO: May be add some retries over here before emitting the error.
                    debug("[%s] %s '%s' with address %s, an error occurred while renewing the token: %O", this._context.connectionId, this.type, this.name, this.address, err);
                }
            }), nextRenewalTimeout);
            debug("[%s] %s '%s' with address %s, has next token renewal in %d seconds @(%s).", this._context.connectionId, this.type, this.name, this.address, nextRenewalTimeout / 1000, new Date(Date.now() + nextRenewalTimeout).toString());
        });
    }
}
exports.ClientEntity = ClientEntity;
//# sourceMappingURL=clientEntity.js.map