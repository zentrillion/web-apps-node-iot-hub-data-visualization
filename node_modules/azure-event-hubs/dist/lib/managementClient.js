"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const uuid = require("uuid/v4");
const rheaPromise = require("./rhea-promise");
const Constants = require("./util/constants");
const debugModule = require("debug");
const rpc_1 = require("./rpc");
const utils_1 = require("./util/utils");
const clientEntity_1 = require("./clientEntity");
const errors_1 = require("./errors");
const debug = debugModule("azure:event-hubs:management");
/**
 * @class ManagementClient
 * Descibes the EventHubs Management Client that talks
 * to the $management endpoint over AMQP connection.
 */
class ManagementClient extends clientEntity_1.ClientEntity {
    /**
     * @constructor
     * Instantiates the management client.
     * @param {BaseConnectionContext} context The connection context.
     * @param {string} [address] The address for the management endpoint. For IotHub it will be
     * `/messages/events/$management`.
     */
    constructor(context, options) {
        super(context, {
            address: options && options.address ? options.address : Constants.management,
            audience: options && options.audience ? options.audience : `${context.config.endpoint}${context.config.entityPath}/$management`
        });
        this.managementLock = `${Constants.managementRequestKey}-${uuid()}`;
        /**
         * @property {string} replyTo The reply to Guid for the management client.
         */
        this.replyTo = uuid();
        this._context = context;
        this.entityPath = context.config.entityPath;
    }
    /**
     * Provides the eventhub runtime information.
     * @param {Connection} connection - The established amqp connection
     * @returns {Promise<EventHubRuntimeInformation>}
     */
    getHubRuntimeInformation() {
        return __awaiter(this, void 0, void 0, function* () {
            const info = yield this._makeManagementRequest(Constants.eventHub);
            const runtimeInfo = {
                path: info.name,
                createdAt: new Date(info.created_at),
                partitionCount: info.partition_count,
                partitionIds: info.partition_ids,
                type: info.type
            };
            debug("[%s] The hub runtime info is: %O", this._context.connectionId, runtimeInfo);
            return runtimeInfo;
        });
    }
    /**
     * Provides an array of partitionIds.
     * @param {Connection} connection - The established amqp connection
     * @returns {Promise<Array<string>>}
     */
    getPartitionIds() {
        return __awaiter(this, void 0, void 0, function* () {
            const runtimeInfo = yield this.getHubRuntimeInformation();
            return runtimeInfo.partitionIds;
        });
    }
    /**
     * Provides information about the specified partition.
     * @param {Connection} connection - The established amqp connection
     * @param {(string|number)} partitionId Partition ID for which partition information is required.
     */
    getPartitionInformation(partitionId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!partitionId || (partitionId && typeof partitionId !== "string" && typeof partitionId !== "number")) {
                throw new Error("'partitionId' is a required parameter and must be of type: 'string' | 'number'.");
            }
            const info = yield this._makeManagementRequest(Constants.partition, partitionId);
            const partitionInfo = {
                beginningSequenceNumber: info.begin_sequence_number,
                hubPath: info.name,
                lastEnqueuedOffset: info.last_enqueued_offset,
                lastEnqueuedTimeUtc: new Date(info.last_enqueued_time_utc),
                lastSequenceNumber: info.last_enqueued_sequence_number,
                partitionId: info.partition,
                type: info.type
            };
            debug("[%s] The partition info is: %O.", this._context.connectionId, partitionInfo);
            return partitionInfo;
        });
    }
    /**
     * Closes the AMQP management session to the Event Hub for this client,
     * returning a promise that will be resolved when disconnection is completed.
     * @return {Promise<void>}
     */
    close() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (this._mgmtReqResLink) {
                    yield rheaPromise.closeSession(this._mgmtReqResLink.session);
                    debug("Successfully closed the management session.");
                    this._session = undefined;
                    this._mgmtReqResLink = undefined;
                    clearTimeout(this._tokenRenewalTimer);
                }
            }
            catch (err) {
                const msg = `An error occurred while closing the management session: ${err}`;
                debug(msg);
                throw new Error(msg);
            }
        });
    }
    _init() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._mgmtReqResLink) {
                yield this._negotiateClaim();
                const rxopt = {
                    source: { address: this.address },
                    name: this.replyTo,
                    target: { address: this.replyTo }
                };
                const sropt = { target: { address: this.address } };
                debug("Creating a session for $management endpoint");
                this._mgmtReqResLink = yield rpc_1.createRequestResponseLink(this._context.connection, sropt, rxopt);
                this._session = this._mgmtReqResLink.session;
                debug("[%s] Created sender '%s' and receiver '%s' links for $management endpoint.", this._context.connectionId, this._mgmtReqResLink.sender.name, this._mgmtReqResLink.receiver.name);
                yield this._ensureTokenRenewal();
            }
        });
    }
    /**
     * @private
     * Helper method to make the management request
     * @param {Connection} connection - The established amqp connection
     * @param {string} type - The type of entity requested for. Valid values are "eventhub", "partition"
     * @param {string | number} [partitionId] - The partitionId. Required only when type is "partition".
     */
    _makeManagementRequest(type, partitionId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (partitionId && typeof partitionId !== "string" && typeof partitionId !== "number") {
                throw new Error("'partitionId' is a required parameter and must be of type: 'string' | 'number'.");
            }
            try {
                const request = {
                    body: Buffer.from(JSON.stringify([])),
                    message_id: uuid(),
                    reply_to: this.replyTo,
                    application_properties: {
                        operation: Constants.readOperation,
                        name: this.entityPath,
                        type: `${Constants.vendorString}:${type}`
                    }
                };
                if (partitionId && type === Constants.partition) {
                    request.application_properties.partition = partitionId;
                }
                yield utils_1.defaultLock.acquire(this.managementLock, () => { return this._init(); });
                return rpc_1.sendRequest(this._context.connection, this._mgmtReqResLink, request);
            }
            catch (err) {
                err = errors_1.translate(err);
                debug("An error occurred while making the request to $management endpoint: %O", err);
                throw err;
            }
        });
    }
}
exports.ManagementClient = ManagementClient;
//# sourceMappingURL=managementClient.js.map