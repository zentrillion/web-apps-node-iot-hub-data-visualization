import * as rhea from "rhea";
export { Delivery, Message, OnAmqpEvent, MessageProperties, MessageHeader, EventContext, Connection, ReceiverOptions, SenderOptions, ConnectionOptions, AmqpError, Dictionary } from "rhea";
/**
 * Establishes an amqp connection.
 * @param {ConnectionOptions} [options] Options to be provided for establishing an amqp connection.
 * @return {Promise<Connection>} Promise<Connection>
 * - **Resolves** the promise with the Connection object when rhea emits the "connection_open" event.
 * - **Rejects** the promise with an AmqpError when rhea emits the "connection_close" event while trying
 * to establish an amqp connection.
 */
export declare function connect(options?: rhea.ConnectionOptions): Promise<rhea.Connection>;
/**
 * Closes the amqp connection.
 * @param {Connection} connection The amqp connection that needs to be closed.
 * @return {Promise<void>} Promise<void>
 * - **Resolves** the promise when rhea emits the "connection_close" event.
 * - **Rejects** the promise with an AmqpError when rhea emits the "connection_error" event while trying
 * to close an amqp connection.
 */
export declare function closeConnection(connection: rhea.Connection): Promise<void>;
/**
 * Creates an amqp session on the provided amqp connection.
 * @param {Connection} connection The amqp connection object
 * @return {Promise<Session>} Promise<Session>
 * - **Resolves** the promise with the Session object when rhea emits the "session_open" event.
 * - **Rejects** the promise with an AmqpError when rhea emits the "session_close" event while trying
 * to create an amqp session.
 */
export declare function createSession(connection: rhea.Connection): Promise<rhea.Session>;
/**
 * Closes the amqp session.
 * @param {Session} session The amqp session that needs to be closed.
 * @return {Promise<void>} Promise<void>
 * - **Resolves** the promise when rhea emits the "session_close" event.
 * - **Rejects** the promise with an AmqpError when rhea emits the "session_error" event while trying
 * to close an amqp session.
 */
export declare function closeSession(session: rhea.Session): Promise<void>;
/**
 * Creates an amqp sender on the provided amqp session.
 * @param {Session} session The amqp session object on which the sender link needs to be established.
 * @param {SenderOptions} [options] Options that can be provided while creating an amqp sender.
 * @return {Promise<Sender>} Promise<Sender>
 * - **Resolves** the promise with the Sender object when rhea emits the "sender_open" event.
 * - **Rejects** the promise with an AmqpError when rhea emits the "sender_close" event while trying
 * to create an amqp sender.
 */
export declare function createSender(session: rhea.Session, options?: rhea.SenderOptions): Promise<rhea.Sender>;
/**
 * Creates an amqp sender on the provided amqp session.
 * @param {Session} session The amqp session object on which the sender link needs to be established.
 * @param {OnAmqpEvent} onError The event handler for the "error" event for the sender.
 * @param {SenderOptions} [options] Options that can be provided while creating an amqp sender.
 * @return {Promise<Sender>} Promise<Sender>
 * - **Resolves** the promise with the Sender object when rhea emits the "sender_open" event.
 * - **Rejects** the promise with an AmqpError when rhea emits the "sender_close" event while trying
 * to create an amqp sender.
 */
export declare function createSenderWithHandlers(session: rhea.Session, onError: rhea.OnAmqpEvent, options?: rhea.SenderOptions): Promise<rhea.Sender>;
/**
 * Closes the amqp sender.
 * @param {Sender} sender The amqp sender that needs to be closed.
 * @return {Promise<void>} Promise<void>
 * - **Resolves** the promise when rhea emits the "sender_close" event.
 * - **Rejects** the promise with an AmqpError when rhea emits the
 * "sender_error" event while trying to close an amqp sender.
 */
export declare function closeSender(sender: rhea.Sender): Promise<void>;
/**
 * Creates an amqp receiver on the provided amqp session. This method should be used when you will be
 * sending a request and waiting for a response from the service. For example: This method is useful
 * while creating request/response links for $management or $cbs endpoint.
 * @param {Session} session The amqp session object on which the receiver link needs to be established.
 * @param {ReceiverOptions} [options] Options that can be provided while creating an amqp receiver.
 * @return {Promise<Receiver>} Promise<Receiver>
 * - **Resolves** the promise with the Receiver object when rhea emits the "receiver_open" event.
 * - **Rejects** the promise with an AmqpError when rhea emits the "receiver_close" event while trying
 * to create an amqp receiver.
 */
export declare function createReceiver(session: rhea.Session, options?: rhea.ReceiverOptions): Promise<rhea.Receiver>;
/**
 * Creates an amqp receiver with provided message and error event handlers on the provided amqp session.
 * This method should be used when you want to ensure that no messages are lost. For example: This method
 * is useful for creating EventHub Receivers where you want to start receiving ASAP.
 * @param {Session} session The amqp session object on which the receiver link needs to be established.
 * @param {OnAmqpEvent} onMessage The event handler for the "message" event for the receiver.
 * @param {OnAmqpEvent} onError The event handler for the "error" event for the receiver.
 * @param {ReceiverOptions} [options] Options that can be provided while creating an amqp receiver.
 * @return {Promise<Receiver>} Promise<Receiver>
 * - **Resolves** the promise with the Receiver object when rhea emits the "receiver_open" event.
 * - **Rejects** the promise with an AmqpError when rhea emits the "receiver_close" event while trying
 * to create an amqp receiver.
 */
export declare function createReceiverWithHandlers(session: rhea.Session, onMessage: rhea.OnAmqpEvent, onError: rhea.OnAmqpEvent, options?: rhea.ReceiverOptions): Promise<rhea.Receiver>;
/**
 * Closes the amqp receiver.
 * @param {Receiver} receiver The amqp receiver that needs to be closed.
 * @return {Promise<void>} Promise<void>
 * - **Resolves** the promise when rhea emits the "receiver_close" event.
 * - **Rejects** the promise with an AmqpError when rhea emits the
 * "receiver_error" event while trying to close an amqp receiver.
 */
export declare function closeReceiver(receiver: rhea.Receiver): Promise<void>;
/**
 * Defines a mapping for Http like response status codes for different status-code values provided by an AMQP broker.
 * @enum AmqpResponseStatusCode
 */
export declare enum AmqpResponseStatusCode {
    Continue = 100,
    SwitchingProtocols = 101,
    OK = 200,
    Created = 201,
    Accepted = 202,
    NonAuthoritativeInformation = 203,
    NoContent = 204,
    ResetContent = 205,
    PartialContent = 206,
    Ambiguous = 300,
    MultipleChoices = 300,
    Moved = 301,
    MovedPermanently = 301,
    Found = 302,
    Redirect = 302,
    RedirectMethod = 303,
    SeeOther = 303,
    NotModified = 304,
    UseProxy = 305,
    Unused = 306,
    RedirectKeepVerb = 307,
    TemporaryRedirect = 307,
    BadRequest = 400,
    Unauthorized = 401,
    PaymentRequired = 402,
    Forbidden = 403,
    NotFound = 404,
    MethodNotAllowed = 405,
    NotAcceptable = 406,
    ProxyAuthenticationRequired = 407,
    RequestTimeout = 408,
    Conflict = 409,
    Gone = 410,
    LengthRequired = 411,
    PreconditionFailed = 412,
    RequestEntityTooLarge = 413,
    RequestUriTooLong = 414,
    UnsupportedMediaType = 415,
    RequestedRangeNotSatisfiable = 416,
    ExpectationFailed = 417,
    UpgradeRequired = 426,
    InternalServerError = 500,
    NotImplemented = 501,
    BadGateway = 502,
    ServiceUnavailable = 503,
    GatewayTimeout = 504,
    HttpVersionNotSupported = 505,
}
/**
 * Describes the delivery annotations.
 * @interface
 */
export interface EventHubDeliveryAnnotations extends rhea.DeliveryAnnotations {
    /**
     * @property {string} [last_enqueued_offset] The offset of the last event.
     */
    last_enqueued_offset?: string;
    /**
     * @property {number} [last_enqueued_sequence_number] The sequence number of the last event.
     */
    last_enqueued_sequence_number?: number;
    /**
     * @property {number} [last_enqueued_time_utc] The enqueued time of the last event.
     */
    last_enqueued_time_utc?: number;
    /**
     * @property {number} [runtime_info_retrieval_time_utc] The retrieval time of the last event.
     */
    runtime_info_retrieval_time_utc?: number;
    /**
     * @property {string} Any unknown delivery annotations.
     */
    [x: string]: any;
}
/**
 * Map containing message attributes that will be held in the message header.
 */
export interface EventHubMessageAnnotations extends rhea.MessageAnnotations {
    /**
     * @property {string | null} [x-opt-partition-key] Annotation for the partition key set for the event.
     */
    "x-opt-partition-key"?: string | null;
    /**
     * @property {number} [x-opt-sequence-number] Annontation for the sequence number of the event.
     */
    "x-opt-sequence-number"?: number;
    /**
     * @property {number} [x-opt-enqueued-time] Annotation for the enqueued time of the event.
     */
    "x-opt-enqueued-time"?: number;
    /**
     * @property {string} [x-opt-offset] Annotation for the offset of the event.
     */
    "x-opt-offset"?: string;
    /**
     * @property {any} Any other annotation that can be added to the message.
     */
    [x: string]: any;
}
